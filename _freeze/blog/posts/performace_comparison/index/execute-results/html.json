{
  "hash": "8ac76d0c23164b5e733e3d58d5457689",
  "result": {
    "markdown": "---\ntitle: \"주요 패키지의 성능비교\"\nauthor: \"JYH\"\ndate: \"2023-04-10\"\ncategories: [R, group_by, test, dplyr, data.table]\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(dtplyr)\nlibrary(microbenchmark)\nlibrary(ggplot2)\n```\n:::\n\n\n# 데이터프레임 성능 비교하기\n\n단순하면서도 가장 많이 활용되는 그룹 별 데이터 요약하기 성능 테스트를 진행해보았습니다.\n\n실험에 사용된 데이터는 `ggplot2`의 `diamonds` 데이터입니다.\n\n성능 비교를 위해 사용된 방법들은 다음과 같습니다.\n\n-   `base R`\n-   `dplyr 1.0`\n-   `dplyr 1.1`\n-   `dtplyr`\n-   `data.table`\n-   `data.table` 1.14.9 (dev)\n\n## 1. base R\n\n외부 패키지 없이 그룹별로 요약값을 계산하려면 `aggregate()`을 사용해야 합니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseR = aggregate(diamonds[,c(\"price\", \"depth\",\"carat\")],\n            by = list(diamonds$color, diamonds$cut),\n            FUN = mean)\n```\n:::\n\n\n## 2. dplyr\n\n가장 많은 R 사용자들이 활용할 것으로 예상되는 `dplyr`의 방법입니다. `dplyr`의 경우, 최근에 업데이트된 1.1 버전과 1.0 버전을 가지고 비교를 해보았습니다.\n\n### 1) dplyr 1.0\n\ndplyr에서 `group_by()` 와 `summarise()`를 통해 분석을 그룹 별 요약 값을 계산하는 방법입니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n    group_by(color, cut) |> \n    summarise(across(c(price, depth, carat), mean, na.rm=T)) |> \n    ungroup()\n```\n:::\n\n\n### 2) dplyr 1.1\n\n`dplyr` 버전 1.1에서부터는 `group_by()`를 따로 사용하지 않더라도, 각각의 함수에서 `.by` 인자를 통해 그룹 변수를 지정해줄 수 있게 되었습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n    summarise(across(c(price, depth, carat), mean),\n              .by=c(color, cut))\n```\n:::\n\n\n## 3. dtplyr\n\n`dtplyr`는 dplyr의 코드와 `data.table`의 backend를 합쳐놓은 패키지입니다. `dplyr`와 같은 코드를 활용해 `data.table`과 같이 빠른 성능을 낼 수 있는 패키지입니다.\n\n::: callout-warning\n비록 `dtplyr`가 `data.table`처럼 빠른 성능을 보여줄 수 있다고는 하나, 순수한 `data.table`보다는 성능이 떨어지는 것으로 알려져 있습니다. 그 이유는 `dplyr`의 코드를 `data.table` 문법으로 변경하는 과정에서 걸리는 시간 때문입니다.[^1]\n:::\n\n[^1]: https://dtplyr.tidyverse.org\n\ndtplyr에서는 lazy_dt()를 이용해 데이터를 `dtplyr` 클래스로 만들어줍니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlazy_dt(diamonds) |> \n    summarise(across(c(price, depth, carat), mean))\n```\n:::\n\n\n## 4. data.table\n\n속도로 잘 알려진 `data.table` 입니다.\n\n`data.table` 같은 경우, 총 4개의 버전으로 비교해보았습니다.\n\n### 1) j, by만 이용\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.table(diamonds)[,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)), \n                  by=.(color, cut)]\n```\n:::\n\n\n### 2) lapply + .SD 이용\n\nlapply + .SD 문법을 이용하여 계산하고자 하는 변수들을 동시에 입력해줍니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.table(diamonds)[,lapply(.SD, mean),.SDcols=c(\"price\",\"depth\",\"carat\"), by=.(color, cut)]\n```\n:::\n\n\n### 3) lapply + .SD + keyby\n\nkeyby를 이용해, 그룹 변수를 key로 만들어줌으로써, 그룹 변수를 기준으로 데이터를 정렬합니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.table(diamonds)[,lapply(.SD, mean),.SDcols=c(\"price\",\"depth\",\"carat\"), keyby=.(color, cut)]\n```\n:::\n\n\n### 4) data.table 개발 버전 (1.14.9)\n\n현재 github에 공개되어있는 1.14.9 버전에서는 `data.table` 클래스가 아닌 데이터셋도 `DT()`를 이용해 `data.table` 문법을 적용할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> DT(,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)),\n           by=.(color, cut))\n```\n:::\n\n\n이제, `microbenchmark` 패키지를 이용해 성능 비교를 진행한 뒤, 이를 boxplot으로 그려 시각화를 해보겠습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2023)\nresult <- microbenchmark(\n  baseR = aggregate(diamonds[,c(\"price\", \"depth\",\"carat\")],\n            by = list(diamonds$color, diamonds$cut),\n            FUN = mean),\n  dplyr_1_0= diamonds |>\n    group_by(color, cut) |> \n    summarise(across(c(price, depth, carat), mean, na.rm=T)) |> \n    ungroup(),\n  dplyr_1_1 = diamonds |> \n    summarise(across(c(price, depth, carat), mean),\n              .by=c(color, cut)),\n  dtplyr = lazy_dt(diamonds) |> \n    summarise(across(c(price, depth, carat), mean),\n              .by=c(color, cut)),\n  dt = as.data.table(diamonds)[,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)), \n                  by=.(color, cut)],\n  dt_lapply_sd = as.data.table(diamonds)[,lapply(.SD, mean),.SDcols=c(\"price\",\"depth\",\"carat\"), by=.(color, cut)],\n  dt_DT = diamonds |> DT(,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)),\n           by=.(color, cut)),\n  dt_key = as.data.table(diamonds)[,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)),\n              keyby=.(color, cut)],\n  times=50\n  \n)\n```\n:::\n\n\n::: panel-tabset\n## table\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nUnit: milliseconds\n         expr        min         lq       mean     median         uq        max\n        baseR  10.410310  10.792922  11.653929  11.138675  12.645958  14.675909\n    dplyr_1_0 116.011755 119.210657 122.416272 120.170016 122.617511 172.123658\n    dplyr_1_1   2.846015   3.014402   3.466315   3.101978   3.274424  10.138726\n       dtplyr   3.357736   3.651173   3.884060   3.757506   4.052358   5.929543\n           dt   1.495639   1.768658   2.344626   1.965130   2.151598  13.240663\n dt_lapply_sd   1.458452   1.824213   2.267091   1.944548   2.221749   6.804606\n        dt_DT   1.162227   1.529054   1.775686   1.659844   1.853692   4.765758\n       dt_key   1.235289   1.590882   1.836510   1.696559   1.819416   4.183107\n neval\n    50\n    50\n    50\n    50\n    50\n    50\n    50\n    50\n```\n:::\n:::\n\n\n## boxplot\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}