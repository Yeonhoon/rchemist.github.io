{
  "hash": "2ca8f29a809529d41e1e0ed00df2e6d9",
  "result": {
    "markdown": "---\ntitle: \"주요 패키지의 성능비교\"\ndescription: \"주요 패키지들의 그룹별 계산 속도 비교\"\nauthor: \"JYH\"\ndate: \"2023-04-10\"\ncategories: [R, group_by, test, dplyr, data.table]\n---\n\n::: {.cell}\n\n:::\n\n\n# 데이터프레임 성능 비교하기\n\nbase R 함수들을 공부하다 `aggregate()`를 알게 되었습니다. 그러다 문득, 이 기본 함수가 다른 패키지들의 그룹 함수와 얼마나 성능 차이가 나는지 궁금해졌습니다.\n\n그래서 단순하면서도 가장 많이 활용되는 [**그룹 별 데이터 요약하기**]{.underline} 성능 테스트를 진행해보았습니다.\n\n실험에 사용된 데이터는 `ggplot2`의 `diamonds` 데이터입니다.\n\n성능 비교를 위해 사용된 방법들은 다음과 같습니다.\n\n-   `base R`\n-   `dplyr 1.0`\n-   `dplyr 1.1`\n-   `dtplyr`\n-   `data.table`\n-   `data.table` 1.14.9 (dev)\n\n## 1. base R\n\n외부 패키지 없이 그룹 별로 요약값을 계산하려면 `aggregate()`을 사용해야 합니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseR = aggregate(diamonds[,c(\"price\", \"depth\",\"carat\")],\n            by = list(diamonds$color, diamonds$cut),\n            FUN = mean)\n```\n:::\n\n\n## 2. dplyr\n\n가장 많은 R 사용자들이 활용할 것으로 예상되는 `dplyr`의 방법입니다. `dplyr`의 경우, 최근에 업데이트된 1.1 버전과 1.0 버전을 가지고 비교를 해보았습니다.\n\n### 1) dplyr 1.0\n\ndplyr에서 `group_by()` 와 `summarise()`를 통해 분석을 그룹 별 요약 값을 계산하는 방법입니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n    group_by(color, cut) |> \n    summarise(across(c(price, depth, carat), mean, na.rm=T)) |> \n    ungroup()\n```\n:::\n\n\n### 2) dplyr 1.1\n\n`dplyr` 버전 1.1에서부터는 `group_by()`를 따로 사용하지 않더라도, 각각의 함수에서 `.by` 인자를 통해 그룹 변수를 지정해줄 수 있게 되었습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n    summarise(across(c(price, depth, carat), mean),\n              .by=c(color, cut))\n```\n:::\n\n\n## 3. dtplyr\n\n`dtplyr`는 dplyr의 코드와 `data.table`의 backend를 합쳐놓은 패키지입니다. `dplyr`와 같은 코드를 활용해 `data.table`과 같이 빠른 성능을 낼 수 있는 패키지입니다.\n\n::: callout-warning\n비록 `dtplyr`가 `data.table`처럼 빠른 성능을 보여줄 수 있다고는 하나, 순수한 `data.table`보다는 성능이 떨어지는 것으로 알려져 있습니다. 그 이유는 `dplyr`의 코드를 `data.table` 문법으로 변경하는 과정에서 걸리는 시간 때문입니다.[^1]\n:::\n\n[^1]: https://dtplyr.tidyverse.org\n\n`dtplyr`에서는 `lazy_dt()`를 이용해 데이터를 `dtplyr` 클래스로 만들어줍니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlazy_dt(diamonds) |> \n    summarise(across(c(price, depth, carat), mean))\n```\n:::\n\n\n## 4. data.table\n\n속도로 잘 알려진 `data.table` 입니다.\n\n`data.table` 같은 경우, 총 4개의 버전으로 비교해보았습니다.\n\n### 1) j, by만 이용\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.table(diamonds)[,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)), \n                  by=.(color, cut)]\n```\n:::\n\n\n### 2) `lapply` + `.SD` 이용\n\n`lapply` + `.SD` 문법을 이용하여 계산하고자 하는 변수들을 동시에 입력해줍니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.table(diamonds)[,lapply(.SD, mean),.SDcols=c(\"price\",\"depth\",\"carat\"), by=.(color, cut)]\n```\n:::\n\n\n### 3) `lapply` + `.SD` + `keyby`\n\n`data.table`의 장점 중 하나는 key를 설정해 데이터를 정렬할 수 있다는 것이죠. 마찬가지로 `keyby`를 이용해 그룹 변수를 key로 만들어줌으로써, 그룹 변수를 기준으로 데이터를 정렬합니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.table(diamonds)[,lapply(.SD, mean),.SDcols=c(\"price\",\"depth\",\"carat\"), keyby=.(color, cut)]\n```\n:::\n\n\n### 4) data.table 개발 버전 (1.14.9)\n\n현재 github에 공개되어있는 1.14.9 버전에서는 `data.table` 클래스가 아닌 데이터셋도 `DT()`를 이용해 `data.table` 문법을 적용할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> DT(,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)),\n           by=.(color, cut))\n```\n:::\n\n\n이제, `microbenchmark` 패키지를 이용해 성능 비교를 진행한 뒤, 이를 boxplot으로 그려 시각화를 해보겠습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nresult <- microbenchmark(\n  baseR = aggregate(diamonds[,c(\"price\", \"depth\",\"carat\")],\n            by = list(diamonds$color, diamonds$cut),\n            FUN = mean),\n  dplyr_1_0= diamonds |>\n    group_by(color, cut) |> \n    summarise(across(c(price, depth, carat), mean, na.rm=T)) |> \n    ungroup(),\n  dplyr_1_1 = diamonds |> \n    summarise(across(c(price, depth, carat), mean),\n              .by=c(color, cut)),\n  dtplyr = lazy_dt(diamonds) |> \n    summarise(across(c(price, depth, carat), mean),\n              .by=c(color, cut)),\n  dt = as.data.table(diamonds)[,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)), \n                  by=.(color, cut)],\n  dt_lapply_sd = as.data.table(diamonds)[,lapply(.SD, mean),.SDcols=c(\"price\",\"depth\",\"carat\"), by=.(color, cut)],\n  dt_DT = diamonds |> DT(,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)),\n           by=.(color, cut)),\n  dt_key = as.data.table(diamonds)[,.(mean_price = mean(price),\n                     mean_depth = mean(depth),\n                     mean_carat = mean(carat)),\n              keyby=.(color, cut)],\n  times=50\n  \n)\n```\n:::\n\n\n::: panel-tabset\n## table\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nUnit: milliseconds\n         expr        min         lq       mean     median         uq        max\n        baseR  10.552662  11.173197  12.164903  11.546440  12.962560  20.493071\n    dplyr_1_0 116.217042 118.796475 132.369553 123.273039 133.731381 246.319923\n    dplyr_1_1   2.897798   3.051425   3.747189   3.183015   3.350643  16.925046\n       dtplyr   3.506443   3.692419   4.080181   3.911830   4.210495   6.900628\n           dt   1.388014   1.813020   2.963913   2.015950   2.462214  19.836948\n dt_lapply_sd   1.448530   1.809535   2.476250   2.076978   2.352867   7.611691\n        dt_DT   1.215199   1.509661   2.024631   1.710049   1.893708   9.833071\n       dt_key   1.148820   1.475221   2.090865   1.636802   2.269391   5.287114\n neval\n    50\n    50\n    50\n    50\n    50\n    50\n    50\n    50\n```\n:::\n:::\n\n\n## boxplot\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n:::\n\n예상된 결과였지만, 역시 `data.table`을 사용한 방법이 가장 빠른 것으로 나타났습니다.\n\n재미있는 점은 dplyr 1.0의 `group_by()`가 생각보다 느리다는 것이었습니다. 심지어 base R의 `aggregate()`보다 느린 것으로 나타났습니다.\n\n확실히 데이터가 커지면 커질수록 `data.table`이 속도 측면에서 큰 우위를 가져가는 것 같습니다.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}