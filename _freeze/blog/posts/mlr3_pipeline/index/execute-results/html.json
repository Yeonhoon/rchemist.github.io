{
  "hash": "9a9af8864c82f8f97aa3cd1af5ab20c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"mlr3 파이프라인\"\ndescription: \"그래프를 활용해 데이터 전처리 수행방법 익히기\"\nauthor: \"JYH\"\ndate: \"2023-12-15\"\ncategories: [R, mlr3, machine learning]\nimage: \"https://mlr3proba.mlr-org.com/logo.svg\"\n---\n\n\n::: callout-important\n\n## 안내사항\n이 글은 [mlr3book](https://mlr3book.mlr-org.com/)[^_mlr3_setup-1]을 참고하여 작성되었습니다. 국내 R 사용자들에게 잘 알려지지 않은 `mlr3`[^_mlr3_setup-2] 패키지를 활용하여 R에서도 손쉽게 머신러닝을 수행할 수 있다는 것을 보여드리고자 합니다.\n:::\n\n[^_mlr3_setup-1]: https://mlr3book.mlr-org.com/\n\n[^_mlr3_setup-2]: https://mlr3.mlr-org.com/\n\n\n\n## 0. 인트로\n\n전처리를 수행할 수도 있고, 태스크 일부분 선택, 러너 생성 후 예측, 앙상블 등의 작업을 수행할 수 있습니다.\n\n## 1. PipeOp: Pipeline 연산자\n`mlr3pipelines`의 기본 클래스는 `PipeOp`로, pipeline operator의 줄임말입니다. `Task`를 훈련하는 것과 같이 변화를 주는 작업을 수행하고 결과를 출력합니다.\n\n`PipeOp`는 러너와 같이 `$train()`, `$predict()` 메서드를 포함하고 있습니다.  또한 `Learner`처럼 파라미터 뿐만 아니라 하이퍼파라미터를 갖고 있어, 사용자들이 `PipeOp`을 만들 때, `$param_set`을 통해 확인 후 파라미터들을 설정할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nlibrary(mlr3verse)\nlibrary(mlr3pipelines)\nlibrary(mlr3pipelines)\nas.data.table(mlr_pipeops)[1:6,1:2]\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"key\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"label\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"boxcox\",\"2\":\"Box-Cox Transformation of Numeric Features\"},{\"1\":\"branch\",\"2\":\"Path Branching\"},{\"1\":\"chunk\",\"2\":\"Chunk Input into Multiple Outputs\"},{\"1\":\"classbalancing\",\"2\":\"Class Balancing\"},{\"1\":\"classifavg\",\"2\":\"Majority Vote Prediction\"},{\"1\":\"classweights\",\"2\":\"Class Weights for Sample Weighting\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nPipeOp 역시 다른 클래스와 마찬가지로 `po()`라는 sugar function을 통해 만들 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npo_onehot = po('encode', method=\"one-hot\")\npo_onehot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPipeOp: <encode> (not trained)\nvalues: <method=one-hot>\nInput channels <name [train type, predict type]>:\n  input [Task,Task]\nOutput channels <name [train type, predict type]>:\n  output [Task,Task]\n```\n\n\n:::\n:::\n\n\n`PipeOp` 객체를 살펴보면, 아직 훈련되지 않은 것을 알 수 있습니다 (not trained).\n\n또한 Input channels와 Output channels 값은 해당 `PipeOp`의 입력, 출력 유형을 알려줍니다. 예를 들어, 위의 `PipeOp`는 Task를 입력받아 Task 형태로 출력하게 됩니다.\n\n이 부분이 `Learner` 클래스와의 차이점입니다. 러너는 학습 후 아무런 결과를 출력하지 않기 때문입니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntask = tsk(\"penguins\")\npo_onehot_in = list(task$clone()$select(c(\"island\",\"sex\"))$filter(1:10))\npo_onehot_out = po_onehot$train(po_onehot_in)\npo_onehot_out\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$output\n<TaskClassif:penguins> (10 x 6): Palmer Penguins\n* Target: species\n* Properties: multiclass\n* Features (5):\n  - dbl (5): island.Biscoe, island.Dream, island.Torgersen, sex.female,\n    sex.male\n```\n\n\n:::\n:::\n\n\n출력 객체에서 메서드를 통해 `PipeOp` 작업이 수행된 데이터를 확인할 수 있습니다.\n\n::: {.cell}\n\n```{.r .cell-code}\npo_onehot_out$output$head()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"species\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"island.Biscoe\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"island.Dream\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"island.Torgersen\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sex.female\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sex.male\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Adelie\",\"2\":\"0\",\"3\":\"0\",\"4\":\"1\",\"5\":\"0\",\"6\":\"1\"},{\"1\":\"Adelie\",\"2\":\"0\",\"3\":\"0\",\"4\":\"1\",\"5\":\"1\",\"6\":\"0\"},{\"1\":\"Adelie\",\"2\":\"0\",\"3\":\"0\",\"4\":\"1\",\"5\":\"1\",\"6\":\"0\"},{\"1\":\"Adelie\",\"2\":\"0\",\"3\":\"0\",\"4\":\"1\",\"5\":\"NA\",\"6\":\"NA\"},{\"1\":\"Adelie\",\"2\":\"0\",\"3\":\"0\",\"4\":\"1\",\"5\":\"1\",\"6\":\"0\"},{\"1\":\"Adelie\",\"2\":\"0\",\"3\":\"0\",\"4\":\"1\",\"5\":\"0\",\"6\":\"1\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n학습이 됐다면, `$predict()` 메서드를 통해 테스트 데이터를 넣어 결과를 확인할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntask_onepenguin = task$clone()$select(c('island','sex'))$filter(50)\npoin = list(task_onepenguin)\npoout = po_onehot$predict(poin)\npoout$output$data()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"species\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"island.Biscoe\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"island.Dream\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"island.Torgersen\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sex.female\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sex.male\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Adelie\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"1\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n## 2. 그래프: PipeOps의 네트워크\n\n`PipeOp`는 머신러닝 파이프라인에서 개별 단위의 계산들을 대표합니다. 이러한 파이프라인은 `Graph` (`PipeOp`들이 연결되어 데이터의 흐름을 나타내는 객체에 의해 정의될 수 있습니다.\n\n`Graph`를 만드는 가장 편리한 방법은 `%>>%` (double-arrow) 연산자를 이용해 `PipeOp`들을 연결하는 것입니다. `PipeOp`의 연결은 아래와 같이 수행됩니다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npo_mutate = po(\"mutate\",\n               mutation = list(bill_ratio = ~bill_length / bill_depth))\npo_scale = po(\"scale\")\n\ngraph = po_mutate %>>% po_scale\ngraph\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGraph with 2 PipeOps:\n     ID         State sccssors prdcssors\n <char>        <char>   <char>    <char>\n mutate <<UNTRAINED>>    scale          \n  scale <<UNTRAINED>>             mutate\n```\n\n\n:::\n:::\n\n출력결과는 그래프의 레이아웃에 대한 정보를 보여줍니다. \n\n::: .callout-note\n\n## Double arrow 연산자 단축키 설정\n\narrow 연산자 (`%>%` 또는 `|>`)의 단축키는 `ctrl+shift+m`이지만, double-arrow 연산자는 단축키가 없으므로, snippet 설정을 통해 단축키를 만들어줄 수 있습니다!\n\n:::\n\n그래프 객체는 `$plot()` 메서드를 통해 그래프를 시각화할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph$plot(horizontal = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n`$pipeops` 필드를 통해서 그래프에 포함된 각각의 Pipeop 객체의 정보를 확인할 수 있고,\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph$pipeops\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$mutate\nPipeOp: <mutate> (not trained)\nvalues: <mutation=<list>, delete_originals=FALSE>\nInput channels <name [train type, predict type]>:\n  input [Task,Task]\nOutput channels <name [train type, predict type]>:\n  output [Task,Task]\n\n$scale\nPipeOp: <scale> (not trained)\nvalues: <robust=FALSE>\nInput channels <name [train type, predict type]>:\n  input [Task,Task]\nOutput channels <name [train type, predict type]>:\n  output [Task,Task]\n```\n\n\n:::\n:::\n\n\n그래프가 연결된 edge에 대해 접근할 수도 있습니다.\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph$edges\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"src_id\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"src_channel\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dst_id\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dst_channel\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"mutate\",\"2\":\"output\",\"3\":\"scale\",\"4\":\"input\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n`%>>%` 대신` $add_pipe()`와 `$add_edge()` 메서드를 이용해 그래프를 만들어줄 수 있습니다.\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph = Graph$new()$\n  add_pipeop(po_mutate)$\n  add_pipeop(po_scale)$\n  add_edge(\"mutate\", \"scale\")\n```\n:::\n\n\n\nGraph를 만든 뒤에는, Learner처럼 `$train()`, `$predict()`를 이용해 PipeOp들을 적용한 값을 출력할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = graph$train(task$clone()$filter(1:100))\nresult$scale.output$data()[1:3]\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"species\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"island\"],\"name\":[2],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"sex\"],\"name\":[3],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"bill_depth\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"bill_length\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"bill_ratio\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"body_mass\"],\"name\":[7],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"flipper_length\"],\"name\":[8],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"year\"],\"name\":[9],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Adelie\",\"2\":\"Torgersen\",\"3\":\"male\",\"4\":\"0.1875640\",\"5\":\"0.1501137\",\"6\":\"-0.05156323\",\"7\":\"0.06776998\",\"8\":\"-1.2140079\",\"9\":\"-0.9949874\"},{\"1\":\"Adelie\",\"2\":\"Torgersen\",\"3\":\"female\",\"4\":\"-0.9047204\",\"5\":\"0.2968915\",\"6\":\"1.10889548\",\"7\":\"0.17866631\",\"8\":\"-0.4396085\",\"9\":\"-0.9949874\"},{\"1\":\"Adelie\",\"2\":\"Torgersen\",\"3\":\"female\",\"4\":\"-0.4005892\",\"5\":\"0.5904472\",\"6\":\"0.90668922\",\"7\":\"-1.04119333\",\"8\":\"0.9543104\",\"9\":\"-0.9949874\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = graph$predict(task$clone()$filter(101))\nresult$scale.output$head()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"species\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"island\"],\"name\":[2],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"sex\"],\"name\":[3],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"bill_depth\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"bill_length\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"bill_ratio\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"body_mass\"],\"name\":[7],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"flipper_length\"],\"name\":[8],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"year\"],\"name\":[9],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Adelie\",\"2\":\"Biscoe\",\"3\":\"female\",\"4\":\"-0.484611\",\"5\":\"-1.354359\",\"6\":\"-0.9296614\",\"7\":\"0.01232181\",\"8\":\"0.4896707\",\"9\":\"2.984962\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n## 3. 순서가 있는 Learner 파이프라인\n\n`mlr3pipelines`은 주로 머신러닝에서 결측치(`NA`) 대체, 범주 인코딩과 같은 데이터 전처리를 할 때 사용될 것입니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlrn_logreg = lrn(\"classif.log_reg\")\ngraph = po(\"imputesample\") %>>% lrn_logreg\ngraph$plot(horizontal = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\ngraph를 learner로 활용하기 위해서 `as_learner()` 함수를 이용합니다.\n\n::: {.cell}\n\n```{.r .cell-code}\nglrn_sample = as_learner(graph)\nglrn_mode = as_learner(po(\"imputemode\") %>>% lrn_logreg)\n\ndesign = benchmark_grid(\n  tasks = tsk(\"pima\"),\n  learners = list(glrn_sample, glrn_mode),\n  resamplings = rsmp(\"cv\", folds=5)\n)\n\nbmr = benchmark(design)\naggr = bmr$aggregate()[,.(learner_id, classif.ce)]\naggr\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"learner_id\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"classif.ce\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"imputesample.classif.log_reg\",\"2\":\"0.2343944\"},{\"1\":\"imputemode.classif.log_reg\",\"2\":\"0.2330957\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n성능 확인 결과, sampling imputation을 통한 결과가 약간 더 좋게 나오는 것을 알 수 있습니다.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}